#!/bin/env python

"""
Compute Chebyshev coefficients for im_w_of_x.
Used to generate code sections in im_w_of_z.c.
"""

from mpmath import *
import random, sys

mp.dps = 48
mp.pretty = True

tuning = True
final = False # Extra checks, to be turned on in final production run

def dawson_kernel(t):
    return exp(t**2)

def highprecision_imwx(x):
    fz = exp(-x**2)*erfc(mpc(0, -x))
    result = fz.imag
    if final:
        # Check mpmath-computed reference value against mpmath-based brute-force integration
        r2 = 2/sqrt(pi) * exp(-x**2) * quad(dawson_kernel, [0, x])
        if abs(result-r2)/result > 1e-17:
            raise Exception(f"mpmath inaccurate")
    return fz.imag

def cheb(x, C, N):
    """
    Evaluates Chebyshev series at point x.
    In contrast to our final C code, we here use the Clenshaw algorithm
    [e.g. Oliver, J Inst Maths Applics 20, 379 (1977].
    """
    u2 = 0
    u1 = C[N]
    for n in reversed(range(1,N)):
        u = 2*x*u1 - u2 + C[n]
        u2 = u1
        u1 = u
    return x*u1 - u2 + C[0]

def test(asu, bsu, C):
    """
    Checks our Chebyshev interpolant against the target function,
    for lots of random points within given subrange.
    """
    N = len(C) - 1
    halfrange = (bsu - asu) / 2
    center = (bsu + asu) / 2
    NT = 316 # NT+1 should be incommensurate with N+1
    for i in range(NT+1):
        x = cos(i*pi/NT)
        ye = cheb(x, C, N)
        yr = highprecision_imwx(center+halfrange*x)
        r = abs((ye-yr)/yr)
        if r > 1.12e-16:
            raise Exception("test failed: i=%i x=%e yr=%f relerr=%e" % (i, x, yr, r))

def polynomial_coefs(C, N):
    """
    Converts Chebyshev to power-series coefficients for faster computation in the final C code.
    Returns list P such that approximant is just sum_i P_i x^i.
    """
    # Compute coefficients T_ni such that T_n(x) = sum_i T_ni x^i.
    # We also save zeros; this could be done better.
    T = [[1], [0, 1]]
    for n in range(2, N+1):
        t = [ -T[n-2][0] ]
        for i in range(1, n+1):
            if (i-n)%2==1:
                t.append(0)
            elif n>i:
                t.append(2*T[n-1][i-1]-T[n-2][i] )
            else:
                t.append(2*T[n-1][i-1] )
        T.append(t)

    # Compute coefficients of x^i, such that P_i = sum_n C_n T_ni.
    P = []
    for i in range(N+1):
        sum = 0
        for n in range(i, N+1):
            sum += C[n] * T[n][i]
        P.append(sum)

    return P

def print_cheby_coeffs(C):
    for Cs in C:
        for coeff in Cs:
            print('%23.16e' % coeff, end=", ")
        print()
    print()

def print_powerseries_code_for_one_subrange(Cs):
    """
    Prints C code that evaluates one Chebyshev polynomial as power series in r.
    """
    Nout = len(Cs) - 1
    P = polynomial_coefs(Cs, Nout)
    print("        return ", end="")
    for i in range(Nout):
        print('(', end="")
    print()
    for i in reversed(range(1, Nout+1)):
        print('            %+23.16e ) * r' % P[i])
    print('            %+23.16e; }' % P[0])

def print_powerseries_code(C):
    """
    Prints C code that evaluates Chebyshev polynomials as power series in r.
    """
    print("//--- The following code is generated by " + sys.argv[0])
    print("// clang-format off")
    # print("    if (s <= 0) { // rounding errors may cause s=-1 for x simeq a")
    # print_one_pc_case(C[0])
    print("    switch(s) {")
    for s in range(0, len(C)-1):
        print("    case %i: {" % (s))
        print_powerseries_code_for_one_subrange(C[s])
    s = len(C) - 1
    print("    case %i: default: {" % s)
    print_powerseries_code_for_one_subrange(C[s])
    print("    } // switch")
    print("    return -137.035999177; // should never happen, just to prevent compiler warning")
    print("// clang-format on")
    print("//--- End of autogenerated code")

def chebcoef(a, b, S):
    """
    Computes Chebyshev coefficients that interpolate function highprecision_imwx in the range (a,b).
    """
    Nout = 8
    N = 10

    C = [[0 for n in range(Nout+1)] for s in range(S)]

    for s in range(S):
        asu = ((S-s)*a + s*b) / S
        bsu = ((S-s-1)*a + (s+1)*b) / S

        halfrange = (bsu - asu) / 2
        center = (bsu + asu) / 2

        xx = [cos(n*pi/N) for n in range(N+1)]
        yy = [highprecision_imwx(center+halfrange*xx[n]) for n in range(N+1)]

        for m in range(N+1):
            sum = (yy[0] + (-1)**m * yy[N]) / 2
            for n in range(1,N):
                sum += yy[n] * chebyt(m, xx[n])
            if m==0 or m==N+1:
                sum *= 1./N
            else:
                sum *= 2./N

            if ((m > 1 and not final and not tuning) or m>Nout-1) and abs(sum) < 5e-17 * abs(C[s][0]):
                break
            if m > Nout:
                raise Exception(f"N={Nout} exceeded")
            C[s][m] = sum

        # print('%3i %8e %8e %+8e %2i' % (s, asu, bsu, C[s][m-1]/C[s][0], m-1))
        for mm in range(m, Nout+1):
            del C[s][-1]

        test(asu, bsu, C[s])

    # print_cheby_coeffs(C)
    print_powerseries_code(C)

if __name__ == '__main__':
    # hand-tuned for Nmax = 7
    chebcoef(mpf(".94"), mpf("1.8"), 17)
    chebcoef(mpf("1.8"), mpf("3.4"), 29)
    chebcoef(mpf("3.4"), mpf("5.84"), 25)
    chebcoef(mpf("5.84"), mpf("10.9"), 28)
