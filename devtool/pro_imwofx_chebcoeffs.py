#!/bin/env python

"""
Compute Chebyshev coefficients for im_w_of_x.
Used to generate code sections in im_w_of_z.c.
"""

from mpmath import *
import random, sys

mp.dps = 48
mp.pretty = True

tuning = True
final = False # Extra checks, to be turned on in final production run

def dawson_kernel(t):
    return exp(t**2)

def highprecision_imwx(x):
    fz = exp(-x**2)*erfc(mpc(0, -x))
    result = fz.imag
    if final:
        # Check mpmath-computed reference value against mpmath-based brute-force integration
        r2 = 2/sqrt(pi) * exp(-x**2) * quad(dawson_kernel, [0, x])
        if abs(result-r2)/result > 1e-17:
            raise Exception(f"mpmath inaccurate")
    return fz.imag

def cheb(t, C, N):
    """
    Evaluates Chebyshev series at point t (between -1 and +1).
    In contrast to our final C code, we here use the Clenshaw algorithm
    [e.g. Oliver, J Inst Maths Applics 20, 379 (1977].
    """
    u2 = 0
    u1 = C[N]
    for n in reversed(range(1,N)):
        u = 2*t*u1 - u2 + C[n]
        u2 = u1
        u1 = u
    return t*u1 - u2 + C[0]

def test(asu, bsu, C):
    """
    Checks our Chebyshev interpolant against the target function,
    for lots of points within given subrange.
    """
    N = len(C) - 1
    halfrange = (bsu - asu) / 2
    center = (bsu + asu) / 2
    NT = 316 # NT+1 should be incommensurate with N+1
    for i in range(NT+1):
        t = cos(i*pi/NT)
        x = center+halfrange*t
        yr = highprecision_imwx(x)
        mp.dps = 16
        t = mpf(t)
        C = [mpf(c) for c in C]
        ye = cheb(t, C, N)
        r = abs((ye-yr)/yr)
        if r > 1.12e-16:
            u2 = 0
            u1 = C[N]
            msg = "%2i %+22.18f %+22.18f \n" % (N, C[N], u1)
            for n in reversed(range(1,N)):
                u = 2*t*u1 - u2 + C[n]
                msg += "%2i %+22.18f %+22.18f \n" % (n, C[n], u)
                u2 = u1
                u1 = u
            msg += "%2i %+22.18f %+22.18f \n" % (0, C[0], t*u1 - u2 + C[0])
            msg += "%2c %22c %+22.18f \n" % (' ', ' ', yr)
            raise Exception("test failed: i=%i t=%e x=%+22.18f yr=%f err=%+22.18f relerr=%e\n%s" % (i, t, x, yr, ye-yr, r, msg))
        mp.dps = 48

def polynomial_coefs(C):
    """
    Converts Chebyshev to power-series coefficients for faster computation in the final C code.
    Returns list P such that approximant is just sum_i P_i x^i.
    """
    N = len(C) - 1
    # Compute coefficients T_ni such that T_n(x) = sum_i T_ni x^i.
    # We also save zeros; this could be done better.
    T = [[1], [0, 1]]
    for n in range(2, N+1):
        t = [ -T[n-2][0] ]
        for i in range(1, n+1):
            if (i-n)%2==1:
                t.append(0)
            elif n>i:
                t.append(2*T[n-1][i-1]-T[n-2][i] )
            else:
                t.append(2*T[n-1][i-1] )
        T.append(t)

    # Compute coefficients of x^i, such that P_i = sum_n C_n T_ni.
    P = []
    for i in range(N+1):
        sum = 0
        for n in range(i, N+1):
            sum += C[n] * T[n][i]
        P.append(sum)

    return P

def print_cheby_coeffs(C):
    for Cs in C:
        for coeff in Cs:
            print('%23.16e' % coeff, end=", ")
        print()
    print()

def print_clenshaw_code(irange, a, b, C, Nout):
    """
    Prints C code that initializes lookup table for Clenshaw computation of Chebyshev interpolants.
    """
    print("//--- The following code is generated by " + sys.argv[0])
    print("// clang-format off")
    print("static const double aCheb%i = %g;" % (irange, a))
    print("static const double bCheb%i = %g;" % (irange, b))
    print(f"static double chebInterpolant{irange}(double x)")
    print("{")
    print("    static const int nSubranges = %i;" % (len(C)))
    print(f"    static const double invSubwidth = nSubranges / (bCheb{irange} - aCheb{irange});")
    print("    static const double ChebCoeffs[%i * %i] = {" % (len(C), Nout+1))
    for Cs in C:
        print("       ", end="")
        for c in Cs:
            print(" %+22.16e," % c, end="")
        for i in range(len(Cs), Nout+1):
            print(" 0,", end="")
        print("")
    print("    };")
    print(f"    const int s = (int)((x-aCheb{irange})*invSubwidth); // index of subrange")
    print("    faddeeva_nofterms = s;")
    print(f"    const double center = ((nSubranges-0.5)-s)*(aCheb{irange}/nSubranges) + (s+0.5) * (bCheb{irange}/nSubranges);")
    print(f"    const double t = 2 * invSubwidth * (x-center); // coord in subrange, between -1 and +1")
    print(f"    const double *const c = ChebCoeffs + s * {Nout+1};")
    print(f"    return cheb(t, c, {Nout});")
    print("}")
    print("// clang-format on")
    print("//--- End of autogenerated code")

def print_powerseries_code(irange, a, b, C, Nout):
    """
    Prints C code that initializes lookup table for Chebyshev polynomials as power series in r.
    """
    print("//--- The following code is generated by " + sys.argv[0])
    print("// clang-format off")
    print("static const double aCheb%i = %g;" % (irange, a))
    print("static const double bCheb%i = %g;" % (irange, b))
    print(f"static double chebInterpolant{irange}(double x)")
    print("{")
    print("    static const int nSubranges = %i;" % (len(C)))
    print(f"    static const double invSubwidth = nSubranges / (bCheb{irange} - aCheb{irange});")
    print("    static const double Coeffs[%i * %i] = {" % (len(C), Nout+1))
    for Cs in C:
        P = polynomial_coefs(Cs)
        print("       ", end="")
        for p in P:
            print(" %+22.16e," % p, end="")
        for i in range(len(P), Nout+1):
            print(" 0,", end="")
        print("")
    print("    };")
    print(f"    const int s = (int)((x-aCheb{irange})*invSubwidth); // index of subrange")
    print("    faddeeva_nofterms = s;")
    print(f"    const double center = ((nSubranges-0.5)-s)*(aCheb{irange}/nSubranges) + (s+0.5) * (bCheb{irange}/nSubranges);")
    print(f"    const double t = 2 * invSubwidth * (x-center); // coord in subrange, between -1 and +1")
    print(f"    const double *const c = Coeffs + s * {Nout+1};")
    print("    return " + "("*(Nout-1) + f" c[{Nout}] * t", end="")
    for i in reversed(range(1, Nout)):
        print(f" + c[{i}] ) * t", end="")
    print(" + c[0];")
    print("}")
    print("// clang-format on")
    print("//--- End of autogenerated code")

def chebcoef(irange, a, b, S):
    """
    Computes Chebyshev coefficients that interpolate function highprecision_imwx in the range (a,b).
    """
    Nout = 8
    N = Nout

    C = [[0 for n in range(Nout+1)] for s in range(S)]

    for s in range(S):
        asu = ((S-s)*a + s*b) / S
        bsu = ((S-s-1)*a + (s+1)*b) / S

        halfrange = (bsu - asu) / 2
        center = (bsu + asu) / 2

        xx = [cos(n*pi/N) for n in range(N+1)]
        yy = [highprecision_imwx(center+halfrange*xx[n]) for n in range(N+1)]

        for m in range(N+1):
            sum = (yy[0] + (-1)**m * yy[N]) / 2
            for n in range(1,N):
                sum += yy[n] * chebyt(m, xx[n])
            if m==0 or m==N+1:
                sum *= 1./N
            else:
                sum *= 2./N

            #if ((m > 1 and not final and not tuning) or m>Nout) and abs(sum) < 5e-17*abs(C[s][0]):
            #    break
            #if m > Nout:
            #    raise Exception(f"N={Nout} exceeded")
            C[s][m] = sum

        # print('%3i %8e %8e %+8e %2i' % (s, asu, bsu, C[s][m-1]/C[s][0], m-1))
        #for mm in range(m, Nout+1):
        #    del C[s][-1]

        test(asu, bsu, C[s])

    # print_cheby_coeffs(C)
    print_clenshaw_code(irange, a, b, C, Nout)
    # print_powerseries_code(irange, a, b, C, Nout)

if __name__ == '__main__':
    # hand-tuned for Nmax = 7
    chebcoef(1, mpf(".94"), mpf("1.8"), 17)
    chebcoef(2, mpf("1.8"), mpf("3.4"), 29)
    chebcoef(3, mpf("3.4"), mpf("5.84"), 25)
    chebcoef(4, mpf("5.84"), mpf("10.9"), 28)
